---
title: "Glioblastoma"
author: "Guilherme Sousa, Karyna Lysenko, Rodrigo Esperanca"
date: "17 de abril de 2023"
output: html_document
encoding: UTF-8
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introdução

Gliomas de baixo grau (LGGs) são tumores cerebrais, de origem em células gliais. LGG representa 30% de neoplasmas do sistema nervoso central pediátrico [2], e em adultos a sua incidência é maior aos __30 e 40 anos__. O sintoma mais comum é a convulsão, embora dores de cabeça e déficits neurológicos focais (por exemplo, visão, fala e audição) também podem ser associados [1]. 
O avanço da genética molecular permitiu identificar alterações genéticas mais comuns e classificar as LGGs. Em 2021, esta classificação passou a ser uma das guidelines da Organização Mundial da Saúde (WHO), onde são descritos os perfis genéticos mutados caraterísticos de cada tipo e que permitem que o tratamento escolhido seja mais direccionado e eficiente [3]. O avanço da genética molecular deveu-se muito pelo avanço tecnológico, nomeadamente, pelo aparecimento da análise transcripcional automatizado e pela criação de bases de dados mundiais de dados clínicos. Neste contexto, o National Cancer Institute (NCI) e o National Human Genome Research Institute (NHGRI), criaram vários projetos e reuniram dados associados a várias patologias. Um desses projetos é o TCGA-LGG que faz parte do programa The Cancer Genome Atlas (TCGA) [4]. Com isto, o objetivo deste trabalho foi recolher os dados do perfil transcripcional................
<http://rmarkdown.rstudio.com>.

## Preparação dos dados
Com o intuito de explorar dados relacionados com a patologia referida, em primeiro lugar, exploramos a ferramenta de análise TCGA Biolinks, que fornece uma interface para aceder aos dados do The Cancer Genome Atlas (TCGA), onde há a presença de um atlas completo de alterações genómicas de vários tipos de cancer incluindo LGGs.Esta ferramenta associada a outras que irão ser utilizadas irá permitir a aálise de dados de expressão genética realcionads com o LGG com o intuito de entender a complexidade dos dados a ser apresentados e obter interpretações biológicas relevantes. 
A função GDCquery() é usada para especificar as características dos dados que se deseja consultar, como o tipo de dados (Gene Expression Quantification), o workflow usado para gerar os dados (STAR - Counts) e o projeto TCGA-LGG (The Cancer Genome Atlas - Lower Grade Glioma). Em seguida, a função GDCdownload() é usada para transfereir os dados correspondentes à consulta feita anteriormente.
A função GDCprepare() é usada parapreparar os dados do TCGA para análise no R. Assim a variavel data_rna_LGG contém os dados de expressão genética resumidos por gene e por amostra, juntamente com informações de metadados sobre as amostras.

```{r}
library(TCGAbiolinks)
query_LGG <- GDCquery(project = "TCGA-LGG", 
                  data.category = "Transcriptome Profiling", 
                  data.type = "Gene Expression Quantification", 
                  workflow.type = "STAR - Counts")
GDCdownload(query_LGG)
data_rna_LGG <- GDCprepare(query_LGG, summarizedExperiment = TRUE, save = TRUE, save.filename = "TCGA_LGG.rda")
load("TCGA_LGG.rda")
```

Uma vez que já temos o nosso dataset é extremamente útil conhecermos um pouco melhor os dados que temos a trabalhar, nomeadamente, ao nível de dimensões. Além disso, é importante identificar o que analisdo em cada coluna e linha.

```{r}
class(data_rna_LGG)
dim(data_na_LGG)
names(data_rna_LGG)
colnames(data_rna_LGG)
```

O dataset em questão tem 60660 linhas e 534 colunas, onde cada linha é um gene e coluna é cada amostra analisada, ou seja cada paciente.
Outro aspecto importante a analisar são os metadados, que nos dão informações adicionais sobre os pacientes, neste caso em particular, nomeadamente a idade, sexo, entre outros aspetos. Os metadados são importantes para a interpretação correta dos dados e para permitir a reutilização dos dados por outros pesquisadores. Tendo isso em consideração utilizamos, em primeiro lugar, a biblioteca Biobase que nos facilita a análise dos metadados. Posto isto, com auxilio da função colData foi possível extrair os metadados e ,seguimos a mesma estratégia, ou seja, verificar as dimensóes dos metadados. 

```{r}
library(Biobase)
meta_LGG = colData(data_rna_LGG)
dim(meta_LGG)
```

Os metadados possuem  534 linhas que correspondem a cada paciente e 110 colunas que nos permitirão mais adiante interpretar os dados da expressão genética. Todavia, em R é possivel filtrar os dados e metadados. Sendo que no nosso caso queriamos diminuir o numero de colunas, associadas aos metadados, para ser mais facil definir uma estratégia de análise para o dataset escolhido. Assim, retirarmos as colunas que tinham mais de 50 "not/Not reported/Reported" e "NA", uma vez que, seria erroneo analisar este tipo de colunas.

```{r}
cols_with_not_reported <- which(sapply(meta_LGG,function(x) sum(x == "not reported", na.rm = TRUE)) > 50)
cols_with_Not_Reported <- which(sapply(meta_LGG,function(x) sum(x == "Not Reported", na.rm = TRUE)) > 50)
cols_with_NA <- which(sapply(meta_LGG, function(x) sum(is.na(x))) > 50)
metadata_matriz_clean <- meta_LGG[, -c(cols_with_not_reported, cols_with_Not_Reported, cols_with_NA)] #retirar as colunas que nao queremos
dim(metadata_matriz_clean)
```

Conseguimos filtrar os nossos metadados de 110 colunas para 78 colunas. Claro que seria possível filtrar ainda mais, contudo nesta fase inicial apenas eliminamos essas colunas. Para iniciar a análise a primeira abordagem foi verificar se os dados realmente iam de acordo ao que era expectável segundo a literatura, nomeadamente , o facto de o diagnóstico da patologia estar diretamente associado ao Glioma.

```{r}
freq_table <- table(metadata_matriz_clean$primary_diagnosis)
pie(freq_table,
    main = "Distribuição de diagnósticos primários",
    col = rainbow(length(freq_table)),
    border = "white",
    labels = paste(names(freq_table), ": ", freq_table, sep = ""))
```

Astroctioma, oligodendroglioma e mixed glioma são tipos de tumores cerebrais que surgem a partir de células do sistema nervoso chamadas de células da glia. Esses tumores são classificados como tipos de gliomas devido à sua origem.Os gliomas podem ser classificados em diferentes subtipos com base nas características histológicas (como a aparência das células tumorais ao microscópio) e moleculares (como a presença ou ausência de mutações genéticas específicas). O astroctioma, o oligodendroglioma e o mixed glioma são subtipos específicos de gliomas que apresentam diferenças na sua aparência histológica e perfil molecular.
A distribuição dos pacientes escolhidos em termos de género também pode ser demontrado por um gráfico circular.

```{r}
counts <- table(metadata_matriz_clean$gender)
colors <- c("pink", "lightblue")
pie(counts, col = colors, main = "Distribuição por género")
legend("topright", legend = names(counts), fill = colors)

```

Pela observação do gráfico é possivel verificar que existe um maior número de pacientes do sexo masculino.Podemos ainda realizar teste estatistico como o teste do qui-quadrado para comparar a frquencia de pacientes do sexo masculino e feminino, sendo a hipótese nula que as frequencias observadas são estatisticamente semelhantes e a hipótese alternativo que as frquencias observadas são estatisticamente diferentes.
 
```{r}
chisq.test(counts)
```

Ao analisar o resultado do p-value de 0,03 é possivel concluir que devemos rejeitar a hipótese nula e portanto há diferença significativa entre o numero de pacientes do sexo masculino e feminino. Todavia, a importância biológica depende do contexto e do objetivo da pesquisa, sendo que nesta fase inicial apenas queremos ter uma noção mais gráfica da distribuição do genero dos pacientes, para mais adiante, se acharmos relevante ter isso em consideração.
Outro aspeto essencial quando se está a analisar uma patologia como o cancro é a idade de diagnóstico. Como é sabido quanto mais precoce for a deteção e respetivo tratamento de um cancro maior a probabilidade de sucesso. Posto isto e tendo em conta informações bibliográficas de que o glioma aparece com mais frquencia entre os 30 e 40 anos decidimos verifcar esse aspeto no nosso data set.

```{r}
sem_NA=na.omit(data_rna_LGG$age_at_index)
hist(sem_NA, breaks = seq(10, 90, 10), main = "Idades dos pacientes", xlab = "Faixa-etária", ylab = "Frequência")
summary(sem_Na)
shapiro.test(sem_NA)
```

É possivel verificar que a idade de diagnóstico varia dos 14 anos ate aos 87, sendo que a faixa etária dos 30-40 anos tal como é referido na literatura é aquela com maior frequência. Com base nos valores apresentados, poderíamos esperar que o histograma tenha uma distribuição assimétrica positiva, com uma cauda mais longa à direita e uma maior concentração de valores à esquerda.  A média é de 42,71, o que significa que a idade média é ligeiramente superior à mediana, o que indica que a distribuição é ligeiramente assimétrica positiva. Além disso pela simples observação do gráfico é possivel verificar que muito provavelmente a distribuição dos dados asssocaidos à idade de diagnóstico não seguem uma distribuição normal, o que também é confirmado pelo teste de shapiro obtendo um valor muito baixo do p-value e portanto rejeitando a hipotese nula de que a distribuição seria normal.
Tendo por base o mesmo raciocinio, ou seja, verificar se realmente à uma relação entre a idade de diagnóstico e o facto de o paciente se encontrar vivo ou morto procedemos à análise destes aspetos em simultaneo , tendo claro em atenção valores not reported e NA.

```{r}
merged_data <- data.frame(status_vital = (metadata_matriz_clean$vital_status), 
                          idade_diagnostico = (metadata_matriz_clean$age_at_index))
merged_data <- na.omit(merged_data)
index_not_reported <- which(apply(merged_data, 1, function(x) any(x == "Not Reported")))
merged_data_clean <- subset(merged_data, !row.names(merged_data) %in% index_not_reported)
```
De modo a poder observar a relação entre a idade de diagnóstico e o estado de vida dos pacientes optamos pela realização de um gráfico de bigodes. Onde pela sua simples  interpretação não parece existir uma relação significativa entre o facto de um diagnóstico mais recente estar associado ou não a um determinado estado de vida, quer seja vivo ou morto. Contudo realizamos var teste e t test para realmente verificar se diferença de medias da idade de diagnostico da doença de vivo ou morto eram estatistiscamente diferentes.

```{r}
boxplot(idade_diagnostico ~ status_vital, data = merged_data_clean, 
        main = "Idade de diagnóstico por status vital",
        xlab = "Status vital", ylab = "Idade de diagnóstico")
means <- tapply(merged_data_clean$idade_diagnostico, merged_data_clean$status_vital, mean)
points(means, col = "red", pch = 18, cex = 2, lwd = 2, add = TRUE)
var_test <- var.test(merged_data_clean$idade_diagnostico[vivos], merged_data_clean$idade_diagnostico[mortos])
resultado_teste <- t.test(merged_data_clean$idade_diagnostico[vivos], merged_data_clean$idade_diagnostico[mortos],var.equal = FALSE)
```

A hipótese nula no teste t realizado seria que as médias das idade de diagnóstico entre estado vivo ou morto seriam iguais. Todavia o pvalue foi bastante inferior a 0.05, ou seja h0 foi rejeitado, o que suger,e que há uma diferença estatisticamente significativa entre as idades de diagnóstico dos pacientes vivos e falecidos.

```{r}
dead_data <- subset(merged_data_clean, merged_data_clean$status_vital == "Dead") 
alive_data <- subset(merged_data_clean, merged_data_clean$status_vital == "Alive")
var_test <- var.test(alive_data$idade_diagnostico, dead_data$idade_diagnostico)  resultado_teste <- t.test(alive_data$idade_diagnostico, dead_data$idade_diagnostico,var.equal = FALSE)
```

Em suma, é possivel concluir que de uma simples interpretação dos metadados algumas conclsões podem ser primariamente retiradas. De modo, a juntar a informação relativa ao genero, idade de diagnostico e estado vital decidimos realizar um gráfico de barras que nos permitisse observar nos dois estados vitais possiveis a frquencia de mulheres ou homens numa determinda faixa etária relativa ao diagnóstico da patologia em questão.

```{r}
dead_data <- subset(merged_data_clean_3, merged_data_clean_3$status_vital == "Dead")
alive_data <- subset(merged_data_clean_3, merged_data_clean_3$status_vital == "Alive")
cores <- c("pink", "lightblue")
tabela_dead <- table(dead_data$gender, cut(dead_data$idade_diagnostico, breaks = seq(10, 90, 10)))
tabela_alive <- table(alive_data$gender, cut(alive_data$idade_diagnostico, breaks = seq(10, 90, 10)))
colnames(tabela_dead) <- paste("Dead", colnames(tabela_dead))
colnames(tabela_alive) <- paste("Alive", colnames(tabela_alive))
rownames(tabela_dead) <- c("Female", "Male")
rownames(tabela_alive) <- c("Female", "Male")
barplot(cbind(tabela_dead, tabela_alive), beside = TRUE, col = cores,
        main = "Comparação entre a frquencia  de pacientes mortos e vivos em função da faixa etária e tendo em atenção o genero dos mesmos",
        xlab = "Faixa etária", ylab = "Contagem",
        legend.text = c("Female", "Male"), args.legend = list(x = "topright"))
```

Depois de uma análise mais geral dos metadados, a abordagem seguinte passou pelo tratamento dos dados. Como referido, o nosso dataset tinha 60660 linhas (genes) e portanto era necessário uma filtragem. A nossa abordagem passou também por defenir uma condição associada aos dados, condição essa que escolhemos a partir de uma coluna dos metadados que identificava um determinado gene como mutante ou wildtype.

```{r}
library(DESeq2)
data_de <- data_rna_LGG[,!is.na(data_rna_LGG$paper_IDH.status)] 
ddsSE <- DESeqDataSet(data_de, design = ~ paper_IDH.status)
```

Como primeiro passo na filtragem procedemos à remoção dos dados que não tinham associação mutante ou wildtype, ou seja, eliminamos os genes associados a NA.
Como é expectável, essa filtragem por si só não é suficiente e portanto filtramos as linhas cujo sumatório das contagens é inferior a 10 e, que tem pelo menos mais do que 3 pacientes com contagem superior a 10.

```{r}
keep <- which(rowSums(counts(ddsSE) >= 10) >= 3) 
ddsSE_filtrado <- ddsSE[keep, ] 
```

Após estas duas etapas de filtragem conseguimos passar para um dataset com 32648 linhas(genes). Sendo este o ponto de partida para nas etapas seguintes realizar a normalização dos nossos dados associados às mesmas condições já referidas.

```{r}
ddsSE_norm <- DESeq(ddsSE_filtrado) 
resultsNames(ddsSE_norm) 
res <- results(ddsSE_norm, name = "paper_IDH.status_WT_vs_Mutant") 
dea <- as.data.frame(res)
```

```{r}
mcols(res, use.names = TRUE)
```

A primeira coluna, baseMean, é a média das contagens dos dois grupos (mutante e wildtype), ou seja, é a média da expressão do gene em todas as amostras. Essa medida é calculada a partir dos valores de contagem normalizados pelo tamanho da amostra. A coluna log2FoldChange é a diferença média na expressão do gene entre os dois grupos, em escala log2. Um valor positivo indica que o gene está mais expresso no grupo 1 (WT) em relação ao grupo 2 (Mutant), enquanto um valor negativo indica que o gene está mais expresso no grupo 2 (Mutant) em relação ao grupo 1 (WT). O valor zero indica que não há diferença na expressão entre os dois grupos. A coluna lfcSE é o erro padrão (desvio padrão) estimado do log2FoldChange. A coluna stat é o valor z-score (ou estatística do teste) usado para testar a hipótese nula de que não há diferença na expressão entre os dois grupos. Esse valor é calculado dividindo o log2FoldChange pelo lfcSE. A coluna p-value  é uma medida estatística onde hipótese nula é que os genes não possuem uma expressão diferencial e quando rejeitamos essa hipótese , ou seja , com um pvalue baixo conseguimos obter os genes diferencialmente expressos. A coluna p-adj é o valor p ajustado para correção do teste de múltiplas comparações, geralmente utilizando o método FDR (controle de taxa de falsos positivos). Esse valor é utilizado para determinar a significância estatística dos resultados.

```{r}
summary(res)
```

Pela análise dos valores de LFC podemos concluir que temos mais genes mutantes expressos,todavia a diferença não é muito. Contudo, um aspeto essencial neste tipo de análise é identificar os genes que são diferencialmente expressos. A visualização gráfica desse conjunto de genes é dada por o seguinte código, estando esse genes coloridos a azul e a cinzento temos os genes que não são diferencialmente expressos.

```{r}
plotMA(res, main="DESeq2", ylim=c(-10,10))
```

Como é possivel verificar existem muito pontos classificados como diferencialmente expressos. Assim, o objetivo seguinte seria identificar os genes que representam cada um desses pontos. Para este objetivo 2 estratégias poderiam ser realizadas:
i) com exploração do pvalue <0.05, que permitiria rejeitar  a hipotese nula onde os genes sap igualmente expressos em ambas as condições. 

```{r}
hist(dea$pvalue, breaks=20,col = "grey", border = "white", xlab = "P-value",
     ylab = "Number of genes", main = "P-value value distribution")
genes_pvalue_fi <- rownames(res)[which(dea$pvalue < 0.05)]
pvalue_fi= sum(dea$pvalue < 0.05, na.rm=TRUE)
```

Com esta nova filtragem obtivemos 23323 genes diferencialmente expressos (rejeitamos a hipótese nula) . Todavia, se assumir que a hipótese nula é verdadeira para todos os genes, é expectavel que a´te 5 % dos genes sejam diferencialmente expressos. Posto isto, 1632 genes poderiam ser escolhidos como diferencalmente expressos, o que iria equivaler a cerca de 7 % de falsos positivos face ao que foi obtido (1632/23323 *100). Assim, achamos mais apropriado a seguinte estratégia:
ii) com a exploração de um padj<0.01, onde estamos a aceitar ter uma percentagem máxima de 1% de falsos positivos, o que irá peritir uma maior filtragem.

```{r}
hist(dea$padj, breaks=20,col = "grey", border = "white", xlab = "P-adj",
     ylab = "Number of genes", main = "P-adj value distribution")
genes_padj_fi <- rownames(res)[which(dea$padj < 0.01)]
padj_fi= sum(dea$padj < 0.01, na.rm=TRUE)
```

Com esta nova filtragem obtivemos 20126 genes diferencialmente expressos.

```{r}
BiocManager::install("genefilter", force = TRUE)
library("genefilter")
library("pheatmap")

vsd <- varianceStabilizingTransformation(ddsSE_norm, blind = FALSE)
resOrdered <- res[order(res$padj),]
select <- rownames(head(resOrdered,20))
vsd.counts <- assay(vsd)[select,]
df <- as.data.frame(colData(ddsSE_norm)[,c("paper_IDH.status")])

anno <- as.data.frame(colData(vsd)[, c("paper_IDH.status", "vital_status")])

pheatmap(vsd.counts, show_colnames = F, annotation_col =anno , main="20 genes com maior diferença de expressão\n entre os mutantes e não mutantes")
```

## Including Plots


You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
